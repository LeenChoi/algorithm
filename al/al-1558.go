// 得到目标数组的最少函数调用次数
// medium
/*
* func modify(arr, op, idx) {
* 	if (op == 0) {
* 		arr[idx] = arr[idx] + 1
* 	}
* 	if (op == 1) {
* 		for(i = 0; i < arr.length; i++) {
* 			arr[i] = arr[i] * 2
* 		}
* 	}
* }
*
* 给你一个与 nums 大小相同且初始值全为 0 的数组 arr ，请你调用以上函数得到整数数组 nums 。
*
* 请你返回将 arr 变成 nums 的最少函数调用次数。
*
* 答案保证在 32 位有符号整数以内。
*
*
* 示例 1：
*
* 输入：nums = [1,5]
* 输出：5
* 解释：给第二个数加 1 ：[0, 0] 变成 [0, 1] （1 次操作）。
* 将所有数字乘以 2 ：[0, 1] -> [0, 2] -> [0, 4] （2 次操作）。
* 给两个数字都加 1 ：[0, 4] -> [1, 4] -> [1, 5] （2 次操作）。
* 总操作次数为：1 + 2 + 2 = 5 。
* 示例 2：
*
* 输入：nums = [2,2]
* 输出：3
* 解释：给两个数字都加 1 ：[0, 0] -> [0, 1] -> [1, 1] （2 次操作）。
* 将所有数字乘以 2 ： [1, 1] -> [2, 2] （1 次操作）。
* 总操作次数为： 2 + 1 = 3 。
* 示例 3：
*
* 输入：nums = [4,2,5]
* 输出：6
* 解释：（初始）[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5] （nums 数组）。
* 示例 4：
*
* 输入：nums = [3,2,2,4]
* 输出：7
* 示例 5：
*
* 输入：nums = [2,4,8,16]
* 输出：8
*
*
* 提示：
*
* 1 <= nums.length <= 10^5
* 0 <= nums[i] <= 10^9
*
* 来源：力扣（LeetCode）
* 链接：https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array
* 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*
* ----------------------------------------------------------
* 题解：贪心
* 逆向思维，将结果数组逆推成初始arr，记录次数即可。怎么记？
* 当奇数时，做减 1 操作，当偶数时做除 2 操作。所以遍历一遍将奇数都减 1 改成偶数，然后整体除 2 (或右移)，反复此操作即可。
*
* 这是朴素想法，有更巧妙的方法。

* 每个数的二进制表达里有多少个 1，就说明这个数需要做多少次减 1。因为每个数只能是通过加 1 或者乘 2 累计上去的，
* 乘 2 相当于左移操作，二进制最右边补 0，所以当出现 1 的情况，只能是通过加 1 操作加上去的。
*
* 知道这个特性后，遍历一遍数组，将每个数判断一遍二进制里的 1，统计出整体数组需要多少次加 1 操作，
* 然后找出数组里最大的数，对该数进行右移操作，统计出需要多少次，再加上上面的结果，即是答案。
*
 */

package main

import "fmt"

func main() {
	fmt.Println(minOperations([]int{4, 2, 5}))
}

func minOperations(nums []int) int {
	ans := 0
	max := 0
	for _, nu := range nums {
		if nu > max {
			max = nu
		}
	}
	for _, nu := range nums {
		for nu > 0 {
			if nu&1 == 1 {
				ans++
			}
			nu >>= 1
		}
	}
	for max > 1 {
		ans++
		max >>= 1
	}
	return ans
}
