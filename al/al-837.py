# 新21点
# medium
'''
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

示例 1：
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。

示例 2：
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。

示例 3：
输入：N = 21, K = 17, W = 10
输出：0.73278

提示：
0 <= K <= N <= 10000
1 <= W <= 10000
如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
此问题的判断限制时间已经减少。

---------------------------------------------
题解：动态规划

上面的示例3，假设我已经得分16分的情况下，我再得一次分获胜的概率是多少，即 [16 + 1, 16 + 10] <= 21 的个数除以总个数，就是概率P(16)
因为前提是已经得了16分，只有一次再得分的机会，所以一次得分定胜负，不是赢就是输，所以总分X的赢的概率可以写为 1 或 0
即状态转移数组 dp[] 的 dp[17->21] 可以初始化为 1， 其他都是 0

那么上面的 dp[17->26] 的概率分布为 [1,1,1,1,1,0,0,0,0,0], 所以 当前16分时的概率为
dp[16] = (dp[17] + ... + dp[26]) / 10 == 0.5
依次往前推, 状态转移方程就出来了， dp[x] = sum(dp[x + 1] -> dp[x + w]) / w

上面的状态转移方程就可以求出解了，最后求出 dp[0] 就是解，但是一般 dp[x] 需要好几个dp项共同参与状态转移的时候，就表明有优化空间
像这种 x 项需要 x + 1 到 x + w 的情况可以用两项相减的方法将 x + 1 到 x + w 中间的多余项舍掉

    dp[x] - dp[x + 1] = (dp[x + 1] + ... + dp[x + w]) / w - (dp[x + 2] + ... + dp[x + w + 1]) / w
=>  dp[x] - dp[x + 1] = (dp[x + 1] - dp[x + w + 1]) / w
=>  dp[x] = dp[x + 1] + (dp[x + 1] - dp[x + w + 1]) / w

这样 dp[x] 的状态只需从两项dp项中转移过来，O(1)的复杂度，原来的转移方程还要遍历所以是O(n)

但，注意此项转移方程 x 的取值范围是 0 到 K - 2, 因为 K - 1 时 dp[x + w + 1] 越界了(dp数组长度 K + W)
所以我们要用第一个状态转移方程先把 dp[K - 1]求了，但也没必要O(n)遍历，因为都是 1，0，所以 (N - (K - 1)) / W 直接求了

'''


class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        if K == 0:
            return 1
        dp = [0] * (K + W)
        for i in range(K, min(K + W, N + 1)):
            dp[i] = 1
        dp[K - 1] = min(N - K + 1, W) / W # 要比较下，因为 N 可能比 W 大
        for i in range(K-2, -1, -1):
            dp[i] = dp[i + 1] + (dp[i + 1] - dp[i + W + 1]) / W
        return dp[0]
    


# print(Solution().new21Game(21, 17, 10))
print(Solution().new21Game(1, 0, 1))
print(Solution().new21Game(0, 0, 1))
        
