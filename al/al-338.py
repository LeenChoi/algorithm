# 比特位计数
# medium
'''
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]
进阶:

给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
要求算法的空间复杂度为O(n)。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。

-------------------------------------
题解:
1. 动态规划 + 最高有效位
    7(111) 和 3(11) 前者在高位多个1，再看 13(1101) 和 5(101) 同样前者在高位多个1
    这俩例子都是前者从后者状态+1转变的，那怎么从前者找到后者，7 - 3 = 4 (2^2), 13 - 5 = 8 (2^3),
    不难发现前后者相差 不大于前者的最大2的阶层
2. 动态规划 + 最低有效位
    和上题一样dp找状态转移，上面是找最高位，这个是找最低位，比如：
    还是 7(111) 和 3(11), 7向右移一位得3， 13(1101) 和 6(110)，13右移一位得6
    那么移出去的一位是1还是0 ，可以做 mod 2 运算得出，所以状态转移方程为 p(x) = p(x // 2) + x % 2
3. 汉明权重
    一直做 x = x & (x - 1) 直至 x == 0, 记循环的次数即是1的个数
    所以利用这个理论，也可以做dp的状态转移，p(x) = p(x & (x - 1)) + 1

'''


class Solution:
    def countBits(self, num: int):
        ans = [0] * (num + 1)
        for i in range(1, num + 1):
            ans[i] = ans[i // 2] + i % 2
        return ans


print(Solution().countBits(16))