// 旋转函数
// medium
/*
* 给定一个长度为 n 的整数数组 A 。
*
* 假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：
*
* F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。
*
* 计算F(0), F(1), ..., F(n-1)中的最大值。
*
* 注意:
* 可以认为 n 的值小于 105。
*
* 示例:
*
* A = [4, 3, 2, 6]
*
* F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
* F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
* F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
* F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
*
* 所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
*
*
* 来源：力扣（LeetCode）
* 链接：https://leetcode-cn.com/problems/rotate-function
* 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*
* ----------------------------------------------------------
* 题解：
* 没什么难的，主要是能找到规律。每一次求的 F，其实都是末尾元素清零，并且其他元素自身再加一份。
* 这样的话，可以提前把整个数组的和 sum 求出来，然后每次求 F，先加一个 sum，然后因为此操作中末尾元素多加了一份，
* 所以末尾清零的时候，注意要多减一份。
*
* 先求个 sum 和 F0，然后模拟翻转，数组从后往前遍历一遍，依次求 F，每次循环做上述操作即可，然后求得最大值。
*
 */

package main

import "fmt"

func main() {
	A := []int{4, 3, 2, 6}
	fmt.Println(maxRotateFunction(A))
}

func maxRotateFunction(A []int) int {
	n := len(A)
	sum, sb := 0, 0
	ans := 0
	for i, v := range A {
		sum += v
		sb += i * v
	}
	ans = sb
	for i := n - 1; i > 0; i-- {
		sb = sb + sum - n*A[i]
		ans = max(ans, sb)
	}
	return ans
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
