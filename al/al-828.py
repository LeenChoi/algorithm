# 统计子串中的唯一字符
# hard
'''
我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。

例如：s = "LEETCODE" ，则其中 "L", "T","C","O","D" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。

本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。

由于答案可能非常大，请将结果 mod 10 ^ 9 + 7 后再返回。



示例 1：

输入: "ABC"
输出: 10
解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
示例 2：

输入: "ABA"
输出: 8
解释: 除了 countUniqueChars("ABA") = 1 之外，其余与示例 1 相同。
示例 3：

输入：s = "LEETCODE"
输出：92
 

提示：

0 <= s.length <= 10^4
s 只包含大写英文字符

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

-------------------------------------------------------
题解：
从 s 的所有子串 t 中找出只出现一次的字符的总和，此题可以换个方式推。遍历 s，找出从s[i]开始的，里面只包含某个字符 c 一次的子串有几个，
c <= [a, z]，算出每个 c 的和加一块儿就是以 s[i] 开始的子串的所有和，那么遍历 s 算出总和即可。

怎么找某个 c 字符只含一次的子串有多少个，假设计算从 s[0] 开始的包含'a'一次的子串，比如 s[3], s[7], s[9] 这三位的字符为'a',
那么以 s[3], s[4], s[5], s[6] 结尾的这四个字符串满足，所以 s[0] 开始的只包含'a'一次的子串有 4 个，即 7 - 3 = 4。
以此类推可以算出每个字符的这个和，所以现需要一个数据结构 index 来记录某个字符在哪一位出现，方便上面的计算。以上面的'a'为例，
需要一个数组来记录'a'出现的索引值 [3,7,9]，每个字符都需要记录，所以维护一个哈希表来记录即可，index['a'] = [3,7,9]。

之后还需要一个数据结构 peek，来记录每个字符的子串统计的进展，比如当前要找以 s[4] 开头的包含'a'一次的子串有几个，那么应该是 9 - 7 = 2
前面的 s[3] 已经过了，作废了。peek['a'] 用来记录这个进展，当遍历完 s 中的一个 'a' 之后，peek['a'] 需要 +1，表示下个 a 的索引开始计算。
index 每个字符的数组最后需要再填两个 N，N = len(s)。因为比如要找以 s[8] 开始的含'a'的子串个数，s[8] 之后只剩 s[9] 一个'a'，
所以 s[9] 之后的所有字符结尾的子串都是答案，即 N - 9。这个是两个 N 中的第一个 N 的作用。第二个 N 的作用是，找 s[10] 开始的含'a'的
子串个数时，此时因为后续没有'a'字符了，所以是 N - N = 0 个，比较合理。

遍历 s 计算每个 s[i] 开始的所有字符的子串总和其实是比较费的，其实计算 s[0] 开头的和 s[1] 开头的含'a'的子串个数，这两个数实际是相同的，
s[1] 的答案可以直接继承 s[0] 的，因为都是 7 - 3 = 4。什么时候会有改变，可以发现 s[4] 开始就变了，因为 s[4] 的解是 9 - 7 = 2。
也就是说，当当前遍历的 s[i] == 'a'时，s[i+1] 开始的含一次'a'的子串数应该被替换成新的，此时只有'a'的子串数变了，其他字符的子串数没有变，还可以直接继承 s[3] 的。
所以不需要每个 s[i] 都重新计算一遍子串总和，而是哪个字符有变，单独改下它的子串数即可，其他字符的子串数不变，只做这方面的微调就可以了。

'''

import collections

class Solution:
    def uniqueLetterString(self, s: str) -> int:
        index = collections.defaultdict(list)
        peek = collections.defaultdict(int)
        for i in range(len(s)):
            index[s[i]].append(i)
        for c in index:
            index[c].extend([len(s), len(s)])
        
        def getCnt(c):
            return index[c][peek[c] + 1] - index[c][peek[c]]
        
        ans = 0
        cur = sum(getCnt(c) for c in index)
        for c in s:
            ans += cur
            oldCnt = getCnt(c)
            peek[c] += 1
            cur = cur - oldCnt + getCnt(c)
        return ans % (10 ** 9 + 7)




        