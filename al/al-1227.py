# 飞机座位分配概率
# medium
'''
有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
剩下的乘客将会：
如果他们自己的座位还空着，就坐到自己的座位上，

当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？

示例 1：
输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。

示例 2：
输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
 
提示：
1 <= n <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/airplane-seat-assignment-probability
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

----------------------------------------
题解：动态规划
    假设 dp[i] 为有 i 个座位的时候，第 i 位乘客坐上自己位置的概率
    i == 2 时，第一位乘客有 0.5 的概率坐到自己的位置，那么第 i 位乘客就有 0.5 的概率坐到自己位置，
    i == 3 时，第一位有 1/3 的概率坐到自己位置，那么第 i 位就一定能坐到自己位置
    他还有 1/3 的概率坐到非第二座，此时第二个人上来的时候发现自己座位没了，就要随机找位置

    此场景其实又降到了 i == 2 的情况，自己座没了，但是他如果坐到了第一座，那么随后的入座又会正常
    变相得，第一座就成了此场景下他该入座的位置，所以 i == 3 的概率是从 i == 2 的状态转移过来的

    i == n 时, 第一位有 1/n 的概率坐到自己位置，有 1/n 的概率坐到 >= 2 , < n - 1 的位置，
    当 1/n 的概率坐到某个 x 位置时，前 x 位乘客都会正确入座，但从第 x 位开始会乱掉，对第 x 为来说，
    他有 n - 1 - x + 1 个位置可以选择(除去第 n 座，再加上第一座)，在此 n - x 个座位中最后一个座不能选，
    所以对第 x 位乘客来说，他的场景降到了 f(n - x - 1) 的场景，所以 dp 公式为：

    dp[n] = 1/n + (1/n * dp[2] + ... + 1/n * dp[n-1])
          = 1/n + (1/n * E(i=2:n-1)dp[n-i+1])
          = 1/n * (1 + E(i=2:n-1)dp[n-i+1])

    优化：将 dp[i]、dp[i-1] 式子相减
    dp[n-1] = 1/(n-1) * (1 + E(i=2:n-2)dp[n-i])

    dp[n] - dp[n-1] => n*dp[n] - (n-1)*dp[n-1] = dp[n-1]
                    => n*dp[n] = n*dp[n-1]
                    => dp[n] = dp[n-1] = ... = dp[2]
                    
    # 这个有点不对
    # dp[i] = 1/i + (i-2)/i * dp[i-1] = 1/i * (1 + (i-2) * dp[i-1])

    其实 dp[i] 每一项的结果都恒定为 0.5，除了 dp[1] 是 1

'''


class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        # 下面这个dp过程虽然结果正确（因为dp项恒定0.5），但思路有点不对，没法优化公式
        # dp = [0, 1]
        # for i in range(2, n + 1):
        #     dp.append(1 / i + (i - 2) / i * dp[i - 1])
        # return dp[n]

        return 1 if n == 1 else 0.5

print(Solution().nthPersonGetsNthSeat(2))
