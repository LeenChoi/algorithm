// 验证二叉树的前序序列化
// medium
/*
* 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
*
*      _9_
*     /   \
*    3     2
*   / \   / \
*  4   1  #  6
* / \ / \   / \
* # # # #   # #
* 例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。
*
* 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。
*
* 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。
*
* 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 "1,,3" 。
*
* 示例 1:
*
* 输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
* 输出: true
* 示例 2:
*
* 输入: "1,#"
* 输出: false
* 示例 3:
*
* 输入: "9,#,#,1"
* 输出: false
*
* 来源：力扣（LeetCode）
* 链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree
* 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*
* -----------------------------------------------------------------
* 题解：栈
* 做一个栈，里面存放各节点目前遍历的进度。前序遍历中，当前节点遍历过后需等到左孩子遍历完，再遍历右孩子，
* 这才算把该节点的分支全遍历完，此过程分两个步骤，一是等左孩子遍历完，二是等右孩子遍历完，然后就该把该分支遍历完的状态
* 上移给其父节点的分支了，但这跟当前节点没关系了，当前节点只要记录好上述俩步骤就成。
*
* 那么此题维护栈的过程就是，当字符串遍历到节点数字时，直接入栈，但入栈的不是节点元素，而是状态(0，1，2)。
* 因为此题中节点元素其实啥意义没有，只是要判断前序遍历的有效性，节点里放啥都行，只要有节点就行。
* 0 代表访问了当前节点，1 代表当前节点的左孩子已遍历，2 代表右孩子已遍历。
*
* 当遍历到 # 时，栈顶元素的状态 +1，如果 +1 后等于 2，表明右孩子也遍历完了，那么就要出栈，表示这个节点的分支已经遍历完，
* 此时出栈后的新栈顶元素也要 +1，因为刚刚那个节点分支的状态要上移给他的父节点，同样当前栈顶 +1 后，若等于 2 也要状态上移，以此类推。
*
* 最后，全遍历完，判断下栈是否为空即可。
*
* 注意，有可能中间连续的 # 导致根节点提前出栈，栈为空，此时如果没有判断跳出，后续的节点再入栈，然后后续的都是有效的，
* 那么结果会是正确的，这种情况需要特殊处理下。
*
 */

package main

import "fmt"

func main() {
	// preorder := "9,3,4,#,#,1,#,#,2,#,6,#,#"
	// preorder := "9,#,#,1"
	// preorder := "9,#,92,#,#"
	preorder := "9,3,4,#,#,1,#,#,#,2,#,6,#,#"
	fmt.Println(isValidSerialization(preorder))
}

func isValidSerialization(preorder string) bool {
	stack := []int{}
	for i := 0; i < len(preorder); {
		if preorder[i] == ',' {
			i++
			continue
		}
		if preorder[i] == '#' {
			if len(stack) == 0 {
				return len(preorder) == 1
			}
			for len(stack) > 0 {
				stack[len(stack)-1]++
				if stack[len(stack)-1] == 2 {
					stack = stack[:len(stack)-1]
				} else {
					break
				}
			}
			i++
			// 判下连续多个 '#' 导致根节点提前出栈了
			if len(stack) == 0 && i < len(preorder) {
				return false
			}
		} else {
			for i < len(preorder) && preorder[i] >= '0' && preorder[i] <= '9' {
				i++
			}
			stack = append(stack, 0)
		}
	}
	return len(stack) == 0
}
