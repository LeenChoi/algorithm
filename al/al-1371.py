# 每个元音包含偶数次的最长子字符串
'''
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

示例 1：
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。

示例 2：
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。

示例 3：
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
 
提示：
1 <= s.length <= 5 x 10^5
s 只包含小写英文字母。

-----------------------------------------
题解： 前缀和，奇偶性位运算，哈希表

包含偶数次，很显然是遇到元音字符做亦或运算就行，这里需要用前缀和的思想，将亦或结果记录到hashmap
（和为k的子数组：那个题解的思想）

这题第一想法肯定是遍历s，遇到元音就对应的次数+1，但其实这题的关键不是包含几次，而是包含偶数次，所以用亦或
做一个hashmap，记录五个元音字符出现次数的情况，其实就是记录每个元音字符的亦或结果

五个字符，所以做个(1<<5)大小的数组就可以了，value记录是第几个元素，初始数组都赋给-1，因为0是一个结果(第0个元素)

最后只要填满这个数组，如果重复了就表明距上一次记录的位置开始到目前又迭代了偶数次元音，计算出现在的位置到上一次的距离即可
注意：遇到重复了，不能覆盖原值，因为是要求出最长子串，数组里记录的永远得是第一个出现该情况的位置


'''

class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        a = [-1] * (1 << 5)
        a[0] = 0
        p, ans = 0, 0
        vowel = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}
        for i in range(len(s)):
            if s[i] in vowel:
                p ^= (1 << vowel[s[i]])
            
            if a[p] < 0:
                a[p] = i + 1 # +1是因为要记录 到第几个字母，而不是下标
            else:
                ans = max(ans, i + 1 - a[p])
        return ans


print(Solution().findTheLongestSubstring('leetcodeisgreat'))
