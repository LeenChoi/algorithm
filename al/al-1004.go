// 最大连续1的个数 III
// medium
/*
* 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。
*
* 返回仅包含 1 的最长（连续）子数组的长度。
*
*
*
* 示例 1：
*
* 输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
* 输出：6
* 解释：
* [1,1,1,0,0,1,1,1,1,1,1]
* 粗体数字从 0 翻转到 1，最长的子数组长度为 6。
* 示例 2：
*
* 输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
* 输出：10
* 解释：
* [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
* 粗体数字从 0 翻转到 1，最长的子数组长度为 10。
*
*
* 提示：
*
* 1 <= A.length <= 20000
* 0 <= K <= A.length
* A[i] 为 0 或 1
*
* 来源：力扣（LeetCode）
* 链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii
* 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*
* --------------------------------------------------------
* 题解：滑动窗口
*
* 向右滑动，记录窗口内 0 的个数 cnt。当右边界碰到 1，如果 cnt <= K 就继续向右扩展，如果 cnt > K 则左边界向右收敛
* 当右边界碰到 0，如果 cnt < K，那么右边界向右扩展，如果 cnt >= K，左边界向右收敛，并且维护好 cnt 值。
*
* 左边界不需要收敛到窗口内正好剩 K 个 0，因为要找出的是最大长度，所以窗口保持目前走过的最大长度即可，
* 因为如果当 cnt > K，数组足够长且后续有足够连续的 1，那么当右边界扩展同时，左边界同步收敛，一定能将窗口内的 0 收敛到 K 个
 */

package main

import "fmt"

func main() {
	// A := []int{0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1}
	// K := 3
	A := []int{1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0}
	K := 2
	fmt.Println(longestOnes(A, K))
}

func longestOnes(A []int, K int) int {
	cnt := 0
	l, r := 0, 0
	for ; r < len(A); r++ {
		if A[r] == 0 {
			cnt++
			if cnt > K {
				if A[l] == 0 {
					cnt--
				}
				l++
			}
		} else if cnt > K {
			if A[l] == 0 {
				cnt--
			}
			l++
		}
	}

	return r - l
}
