# 两数之和 II - 输入有序数组
# easy
'''
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

-------------------------------
题解：双指针，二分查找
破题，直接头尾双指针就完了。相关标签写着双指针、二分查找，我以为先二分查找，锁定一个离target相近的数，然后双指针逼近，
没想到，用例里还包括负数，如果 [-99,-2,1,99], target = 0, 那么没法解了。所以直接头尾双指针就完了。

官方题解给的二分查找方法是，遍历一遍数组，遍历 i 时，二分查找找到 i 右半部的 target - i，如果找不到继续查找。
还不如直接hash map呢

还有个相似题 al-653, 输入是一个 bst (二叉搜索树)，直接bfs/dfs + hashmap 解决即可

'''


class Solution:
    def twoSum(self, numbers, target):
        i, j = 0, len(numbers) - 1
        while i < j:
            if numbers[i] + numbers[j] == target:
                return [i + 1, j + 1]
            elif numbers[i] + numbers[j] > target:
                j -= 1
            else:
                i += 1
        

print(Solution().twoSum([-1, 0], -1))
# print(Solution().twoSum([2,7,11,15,18], 29))
# a = [12,13,23,28,43,44,59,60,61,68,70,86,88,92,124,125,136,168,173,173,180,199,212,221,227,230,277,282,306,314,316,321,325,328,336,337,363,365,368,370,370,371,375,384,387,394,400,404,414,422,422,427,430,435,457,493,506,527,531,538,541,546,568,583,585,587,650,652,677,691,730,737,740,751,755,764,778,783,785,789,794,803,809,815,847,858,863,863,874,887,896,916,920,926,927,930,933,957,981,997]
# print(Solution().twoSum(a, 542))