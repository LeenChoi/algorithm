// 基本计算器
// hard
/*
* 实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。
*
* 示例 1：
*
* 输入：s = "1 + 1"
* 输出：2
* 示例 2：
*
* 输入：s = " 2-1 + 2 "
* 输出：3
* 示例 3：
*
* 输入：s = "(1+(4+5+2)-3)+(6+8)"
* 输出：23
*
*
* 提示：
*
* 1 <= s.length <= 3 * 105
* s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
* s 表示一个有效的表达式
*
* 来源：力扣（LeetCode）
* 链接：https://leetcode-cn.com/problems/basic-calculator
* 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*
* ------------------------------------------------------------
* 题解：栈
* 因为算术式只由 +- 和 () 组成，所以此题实际是要控制正负号的变换，'(' 之前如果是 - 号，那么整个括号内的式子都要取反，
* 所以用一个栈，记录各 '(' 前的正负号状态即可，当遇到 ')' 就将当前记录的正负号出栈。
*
* 遍历字符串，记一个 sign 记录当前碰到的 +-，和一个栈 ops 记录当前式子的正负号状态，初始栈顶为正号，没碰到 '(' 之前正常算式，
* 碰到 '(' 就将当前 sign 入栈。注意，改变 sign 状态时，一定是要将 ops 栈顶的状态和当前碰到的 +- 号做叠加，
* 因为可以嵌套很多个 ()，所以当前的 sign 状态不一定已经经过了多少个状态叠加。然后再以这个 sign 去参与算式计算。
*
* 碰到 ')' 将栈顶出栈，退出当前的状态叠加，让 sign 和下一个栈顶做叠加，参与计算
*
 */

package main

func main() {

}

func calculate(s string) int {
	sign := 1
	ops := []int{1}
	n := len(s)
	ans := 0
	for i := 0; i < n; {
		switch s[i] {
		case ' ':
			i++
		case '+':
			sign = ops[len(ops)-1]
			i++
		case '-':
			sign = -ops[len(ops)-1]
			i++
		case '(':
			ops = append(ops, sign)
			i++
		case ')':
			ops = ops[:len(ops)-1]
			i++
		default:
			num := 0
			for ; i < n && s[i] >= '0' && s[i] <= '9'; i++ {
				num = num*10 + int(s[i]-'0')
			}
			ans = ans + sign*num
		}
	}
	return ans
}
